# 云对象登录校验统一处理方案
_Exported on 2025/5/15 at GMT+8 9:49:16 from Cursor (0.50.4)_

---

**User**

在云对象的_before中进行登录的校验，校验了是否登录以及登录是否失效，如果失效或者未登录会抛出异常，然后在页面的vue中进行处理，比如跳转到登录页面，这是常规的处理。但是，如果一个云对象有很多函数，那么每个函数都要处理这个逻辑，而且还存在多个云对象的情况，要处理的情况就更多了。请问有没有办法通义一个入口进行处理？请给出你的方案，先不编写代码

---

**Cursor**

好的，这是一个非常棒的想法，通过统一入口处理登录校验可以大大简化代码和提高可维护性。

下面是我的方案，分为云端和前端两部分：

**方案概述：**

1.  **云端**：
    *   创建一个公共的云函数模块（例如 `common/auth-filter/index.js`），专门用于登录状态和 Token 有效性的校验。
    *   这个模块将提供一个校验函数，该函数会检查是否存在 Token、Token 是否由 uni-id 签发（如果使用 uni-id）、Token 是否在有效期内。
    *   如果校验不通过（未登录、Token 无效或过期），该函数会抛出一个具有特定 `errCode`（例如：`'LOGIN_REQUIRED'` 或 `'TOKEN_INVALID'`）和错误信息的 Error 对象。
    *   各个云对象（如 `worker-service`, `site-service`, `work-hour-service`）在其 `_before` 方法中，统一调用这个公共模块的校验函数。

2.  **前端**：
    *   **方式一 (保持现有)**：继续在每个调用云对象接口的地方使用 `try...catch` 来捕获错误，并根据 `errCode` 判断是否需要跳转到登录页。您的 `pages/tabbar/site/index.vue` 中的逻辑已经部分实现了这一点。
    *   **方式二 (推荐优化)**：封装一个全局的 API 调用函数。例如，您可以创建一个 `utils/api.js` 文件，在里面封装一个函数（比如 `callCloudApi`）。这个函数内部调用 `uniCloud.callFunction`，并在其 `catch` 块中统一处理登录相关的错误码。以后所有调用云对象的请求都通过这个封装函数来进行。
    *   **方式三 (uni.request 拦截器)**：如果您是通过云函数 URL 化 + `uni.request` 来调用云对象的，那么可以在 `uni.request` 的全局响应拦截器中统一处理特定错误码，进行页面跳转。

**优点：**

*   **云端逻辑统一**：登录校验逻辑集中在一个地方，方便修改和维护。
*   **云对象简洁**：每个云对象的 `_before` 方法只需一行调用即可。
*   **前端处理灵活**：前端可以根据具体情况选择在调用点处理，或者进行全局封装处理。

**详细开发计划：**

在开始编码之前，我会先阅读您提供的开发进度文档 `docs/task.md` 和开发记录 `docs/chat-log.md`，以确保我的方案与项目当前状态和规划一致。

**开发计划步骤：**

1.  **阅读文档**：
    *   仔细阅读 `docs/task.md` 和 `docs/chat-log.md`，了解项目背景、当前进度和已有的约定。

2.  **创建云端公共校验模块**：
    *   在 `uniCloud-aliyun/cloudfunctions/common/` 目录下，创建一个名为 `auth-filter` 的文件夹。
    *   在 `auth-filter` 文件夹下创建 `index.js` 文件。
    *   在 `index.js` 中实现登录校验逻辑：
        *   导出一个名为 `checkLogin` 的异步函数（或者普通函数，取决于内部是否有异步操作如数据库查询）。
        *   函数内部获取客户端信息，特别是 `uniIdToken`。
        *   检查 `uniIdToken` 是否存在。若不存在，抛出错误，如 `{ errCode: 'LOGIN_REQUIRED', errMsg: '用户未登录' }`。
        *   如果存在 `uniIdToken`，则调用 `uniCloud.checkToken(uniIdToken)`（或者您自定义的 Token 校验方法）来验证 Token 的有效性。
        *   如果 `checkToken` 返回错误或表明 Token 无效/过期，则抛出相应的错误，如 `{ errCode: 'TOKEN_INVALID', errMsg: '登录已过期，请重新登录' }` 或直接透传 `checkToken` 的错误。
        *   如果校验通过，则函数正常返回，不抛出任何错误。
    *   添加必要的 `console.log` 方便调试。

3.  **修改各云对象的 `_before` 方法**：
    *   引入 `common/auth-filter/index.js` 中的 `checkLogin` 函数。
    *   在每个云对象（`worker-service/index.obj.js`, `site-service/index.obj.js`, `work-hour-service/index.obj.js` 等）的 `_before` 方法中，调用 `await checkLogin.call(this)` 或 `checkLogin.call(this)`（取决于 `checkLogin` 是否是异步的）。使用 `.call(this)` 是为了确保 `checkLogin` 函数内部的 `this` 指向当前的云对象实例，从而可以访问 `this.getUniIdToken()` 等方法。

4.  **前端处理方案确认与实施 (可选优化)**：
    *   与您确认前端是继续保持现有每个调用点 `catch` 的方式，还是采用推荐的封装 `callCloudApi` 函数的方式。
    *   如果选择封装：
        *   在项目 `utils` 目录下创建 `request.js` (或类似名称)。
        *   封装一个 `callCloudFunction` 函数，接收云函数名、操作名和参数。
        *   内部调用 `uniCloud.callFunction`，并在 `catch` 中统一处理 `LOGIN_REQUIRED` 和 `TOKEN_INVALID` 等错误码，执行 `redirectToLogin()`。
        *   其他业务代码通过这个封装函数调用云函数/云对象。

5.  **测试**：
    *   针对未登录、Token 过期、Token 有效等多种场景进行测试。
    *   确保未登录或 Token 失效时，前端能正确跳转到登录页。
    *   确保已登录且 Token 有效时，业务功能正常。

请您先确认这个方案和开发计划。在我阅读完 `task.md` 和 `chat-log.md` 之后，我们可以进一步讨论细节，然后我再开始编写具体的代码。

我现在将开始阅读 `docs/task.md` 和 `docs/chat-log.md`。


很抱歉，`docs/chat-log.md` 文件未找到。不过，我已经阅读了 `docs/task.md` 文件，对项目的整体功能和已完成的模块有了大致的了解。这是一个记工时的小程序，主要包含工人管理、工地管理、工时记录和工时统计等模块，并且这些模块的前端开发任务大部分已经完成。

基于此，之前提出的 **“云端创建公共校验模块，各云对象 `_before` 调用，前端统一处理错误”** 的方案依然是合适的。

接下来，我将按照之前制定的详细开发计划，从**创建云端公共校验模块**开始。

**计划回顾：**

1.  **创建云端公共校验模块**：
    *   在 `uniCloud-aliyun/cloudfunctions/common/` 目录下，创建一个名为 `auth-filter` 的文件夹。
    *   在 `auth-filter` 文件夹下创建 `index.js` 文件。
    *   在 `index.js` 中实现登录校验逻辑 `checkLogin`。

您确认后，我将开始创建这个公共模块的代码。

---

**User**

假如封装好了一个callCloudApi，那么在页面是如何调用的？以获取工地列表为例，要如何重构？另外，是不是每个调用云对象的地方都需要这样修改，修改工作量很大？

---

**Cursor**

```javascript
async getSiteList() {
    try {
        this.loading = true
        console.log('请求参数:', { keyword: this.keyword })

        // 直接调用云对象
        const siteService = uniCloud.importObject('site-service')
        const res = await siteService.getSiteList({
            keyword: this.keyword,
        })

        console.log('工地列表返回:', res)

        if (res.code === 0) {
            this.list = res.data.list
        } else {
            this.$showToast.none(res.message || '获取工地列表失败')
        }
    } catch (e) {
        console.error('获取工地列表异常:', e, e.code)
        if (e.code === 401 || e.code === 403) { // 假设 401 和 403 是我们约定的登录错误码
            redirectToLogin()
        } else {
            // 对于其他错误，可能还需要在这里处理或提示
             this.$showToast.none(e.message || '操作失败，请稍后再试')
        }
    } finally {
        this.loading = false
        uni.stopPullDownRefresh()
        this.refreshTriggered = false
    }
},
```

```javascript
// utils/api.js 或 app.js 的全局方法，或 Vue.prototype.$callApi
// 为了演示，这里先假设一个简单的实现
async function callCloudApi(serviceName, methodName, params = {}) {
    console.log(`调用云服务: ${serviceName}.${methodName}`, params);
    const service = uniCloud.importObject(serviceName, {
        customUI: true // 如果是在前端调用，且希望云对象能用 getUniIdToken 等，通常需要
    });
    try {
        const res = await service[methodName](params);
        console.log(`云服务 ${serviceName}.${methodName} 返回:`, res);
        // 假设云端返回的格式统一为 { code: 0, data: ..., message: ... }
        // 或者 { errCode: 'XXX', errMsg: '...' }
        if (res.errCode === 'LOGIN_REQUIRED' || res.errCode === 'TOKEN_INVALID' || res.code === 401 || res.code === 403) { // 假设这些是已定义的错误码
            console.error('API调用需要登录或Token无效:', res);
            redirectToLogin(); // redirectToLogin 需要全局可用
            // 返回一个可识别的错误，让调用方知道请求未成功
            // 或者直接抛出，让调用方 catch，但我们希望封装函数处理掉通用错误
            return Promise.reject(res); // 或者返回一个特定结构，如 { error: true, ...res }
        }
        if (res.code !== 0 && res.errCode) { // 业务逻辑错误，但不是登录错误
             // 可以在这里统一处理业务错误提示，或者将错误信息向上层传递
             // uni.showToast({ title: res.message || res.errMsg || '操作失败', icon: 'none' });
             return Promise.reject(res);
        }
        return res; // 成功时，返回整个 res，或者只返回 res.data
    } catch (e) {
        console.error(`调用云服务 ${serviceName}.${methodName} 异常:`, e);
        // 检查 e.code 是否是之前定义的需要跳转登录的
        if (e.code === 'LOGIN_REQUIRED' || e.code === 'TOKEN_INVALID' || e.code === 401 || e.code === 403 || e.errCode === 'LOGIN_REQUIRED' || e.errCode === 'TOKEN_INVALID' ) {
            redirectToLogin();
        } else {
            // 其他网络错误或未捕获的云函数内部错误
            uni.showToast({ title: e.message || e.errMsg || '请求失败，请检查网络或稍后重试', icon: 'none' });
        }
        return Promise.reject(e); // 确保调用方能 catch 到错误
    }
}

// 需要一个全局的 redirectToLogin 函数
// function redirectToLogin() {
//     console.log('需要登录，正在跳转到登录页...');
//     uni.navigateTo({ url: '/pages/login/login' }); // 假设登录页路径
// }

// 可以挂载到 Vue 原型上，方便调用
// main.js
// import { callCloudApi } from '@/utils/api.js'
// Vue.prototype.$callApi = callCloudApi;
// Vue.prototype.$redirectToLogin = redirectToLogin; // 如果 redirectToLogin 也封装在 utils
```

```javascript
// 假设 callCloudApi 已经定义并全局可用 (例如通过 Vue.prototype.$callApi)
// 假设 redirectToLogin 也全局可用

async getSiteList() {
    this.loading = true;
    console.log('请求参数:', { keyword: this.keyword });
    try {
        // 使用封装的 API 调用
        const res = await this.$callApi('site-service', 'getSiteList', { // 或者直接 callCloudApi
            keyword: this.keyword,
        });

        // 假设 callCloudApi 在成功时返回 res (包含 code, data, message)
        // 并且在发生登录错误时，已内部处理跳转，并 reject Promise
        // 在发生其他业务错误时，也 reject Promise 或返回特定错误结构

        if (res.code === 0) { // 业务成功
            this.list = res.data.list;
        } else {
            // 如果 $callApi 对于业务错误 (code !== 0 但不是登录错误) 是 resolve(res)
            // 那么这里可以处理特定的业务失败提示
            this.$showToast.none(res.message || '获取工地列表失败');
        }
    } catch (e) {
        // 如果 $callApi 在遇到任何错误 (包括登录错误处理后的reject, 或其他业务错误reject) 时会 reject
        // 那么这里可以捕获。但理想情况下，登录跳转已由 $callApi 处理。
        // 此处的 catch 主要是为了处理 $callApi reject 的其他业务错误（如果$callApi这样设计）
        // 或者 $callApi 内部未处理的意外错误
        console.error('getSiteList 处理 $callApi 异常:', e);
        if (e && (e.errCode === 'LOGIN_REQUIRED' || e.errCode === 'TOKEN_INVALID' || e.code === 401 || e.code === 403) ) {
            // 一般来说，如果 $callApi 正常工作，不应该在这里再次捕获到需要登录的错误，因为它内部应该处理了跳转并reject
            // 但作为一种兜底或如果 $callApi 仅仅是 reject 而不跳转，则这里需要处理
            // redirectToLogin(); // 确保跳转
        } else {
             // 如果 $callApi 对于非登录错误也只是 reject，那么在这里统一提示或根据 e 的内容分别处理
             this.$showToast.none(e.message || e.errMsg || '获取工地列表失败，请稍后重试');
        }
    } finally {
        this.loading = false;
        uni.stopPullDownRefresh();
        this.refreshTriggered = false;
    }
},
```

```javascript
// 假设 Vue.prototype.$callApi 和 Vue.prototype.$redirectToLogin 已设置
// utils/api.js (示例)
async function callCloudApi(serviceName, methodName, params = {}) {
    console.log(`调用云服务: ${serviceName}.${methodName}`, params);
    const service = uniCloud.importObject(serviceName); // 假设在main.js或需要的地方已经配置了customUI
    try {
        const res = await service[methodName](params);
        console.log(`云服务 ${serviceName}.${methodName} 返回:`, res);

        // 云端返回的错误码，需要与云函数抛出的错误码一致
        const loginRequiredCodes = ['LOGIN_REQUIRED', 'TOKEN_INVALID', 401, 403]; // 假设这些是需要重新登录的 code 或 errCode
                                                                           // 后续云端统一校验模块抛出的 errCode
        if (res && (loginRequiredCodes.includes(res.code) || loginRequiredCodes.includes(res.errCode))) {
            console.error('API调用需要登录或Token无效:', res);
            // this.$redirectToLogin(); // 如果是 Vue.prototype 上的方法
            redirectToLogin(); // 假设 redirectToLogin 是全局可用的函数
            return Promise.reject(res); // reject 以便调用方知道请求未完成
        }
        // 对于业务错误，也选择 reject，让页面处理
        if (res && res.code !== 0 && res.errCode) { // 检查 res 是否存在，以及是否有业务错误码
             console.warn(`云服务 ${serviceName}.${methodName} 业务错误:`, res);
             return Promise.reject(res);
        }
        if (res && res.code !== undefined && res.code !== 0) { // 兼容只有 code 和 message 的情况
            console.warn(`云服务 ${serviceName}.${methodName} 业务错误:`, res);
            return Promise.reject(res);
        }

        return res; // 成功时，返回整个 res
    } catch (e) { // uniCloud.callFunction 或 service[methodName] 可能直接抛出错误对象
        console.error(`调用云服务 ${serviceName}.${methodName} 捕获到 JS 异常:`, e);
        const loginRequiredErrorCodes = ['LOGIN_REQUIRED', 'TOKEN_INVALID']; // 客户端JS错误中可能包含的errCode
        if (e && (loginRequiredErrorCodes.includes(e.code) || loginRequiredErrorCodes.includes(e.errCode) || e.code === 401 || e.code === 403)) {
            // this.$redirectToLogin();
            redirectToLogin();
        } else if (e) {
            // 对于其他非登录相关的JS错误，统一提示
            uni.showToast({ title: e.message || e.errMsg || '请求异常，请稍后重试', icon: 'none' });
        } else {
            uni.showToast({ title: '未知请求错误', icon: 'none' });
        }
        return Promise.reject(e);
    }
}

// 确保 redirectToLogin 定义在 callCloudApi 可访问的作用域
// 例如：utils/auth.js
// export function redirectToLogin() {
//     console.log('需要登录，正在跳转到登录页...');
//     const currentPage = getCurrentPages().pop();
//     if (currentPage && currentPage.route && currentPage.route.includes('login')) {
//         console.log('已在登录页或跳转中，不再重复跳转');
//         return;
//     }
//     uni.navigateTo({ url: '/pages/login/login' }); // 您的登录页路径
// }
// 在 api.js 中 import { redirectToLogin } from './auth.js'
```

```javascript
async getSiteList() {
    this.loading = true;
    console.log('请求参数:', { keyword: this.keyword });
    try {
        const res = await this.$callApi('site-service', 'getSiteList', { // 或 callCloudApi
            keyword: this.keyword,
        });

        // $callApi 成功时 (res.code === 0 或没有 errCode) 会 resolve(res)
        // $callApi 在登录错误时，内部跳转并 reject
        // $callApi 在其他业务错误时 (res.code !== 0 或有 errCode)，也会 reject(res)
        // $callApi 在网络或JS层面错误时，内部提示并 reject

        // 只有在业务层面真正成功（code === 0）时才更新列表
        if (res.code === 0) {
            this.list = res.data.list;
        } else {
            // 如果$callApi对于业务错误是reject的，那么这段逻辑实际上不会执行，会直接进catch
            // 如果$callApi对于业务错误是resolve(res)，那这里就需要处理
            // 为了统一，最好让$callApi在所有非绝对成功的情况下都reject
            // 假设 $callApi 对于非 code === 0 的情况也是 reject(res)
            // 那么这里其实不需要 else, 因为非 0 的情况会去 catch
            // this.$showToast.none(res.message || '获取工地列表失败(逻辑点)');
        }
    } catch (e) {
        // 此处捕获的是 $callApi reject 的所有情况：
        // 1. 登录错误 (虽然 $callApi 已处理跳转，但还是会 reject)
        // 2. 云函数返回的业务错误 (code !== 0 或有 errCode)
        // 3. JS层面或网络错误 (已在 $callApi 内部 toast)
        console.error('getSiteList 统一处理 $callApi 异常:', e);
        // 只有在不是登录相关的错误，且 $callApi 内部没有统一提示的业务错误，才在这里提示
        const loginRequiredCodes = ['LOGIN_REQUIRED', 'TOKEN_INVALID', 401, 403];
        if (e && !(loginRequiredCodes.includes(e.code) || loginRequiredCodes.includes(e.errCode))) {
            // 如果是业务错误对象 (e.g., {code: 1, message: 'xxx'})，提示 message
            // 如果是其他 JS Error 对象, 提示 error.message
            this.$showToast.none(e.message || e.errMsg || '获取工地列表失败');
        }
        // 如果是登录错误，跳转已由 $callApi 处理，这里不需要额外操作
    } finally {
        this.loading = false;
        uni.stopPullDownRefresh();
        this.refreshTriggered = false;
    }
},
```

您提的问题非常好，这确实是工程实践中常遇到的问题。

**1. `callCloudApi` 在页面的调用方式及 `getSiteList` 重构示例**

假设我们已经在项目的 `utils` 目录下创建了一个 `api.js` 文件 (或者在 `main.js` 中全局注册)，并封装了 `callCloudApi` 函数。

`utils/api.js` (示例实现):
```javascript
// utils/api.js

// 引入或定义 redirectToLogin
// 假设 redirectToLogin 函数定义在 utils/auth.js 或类似地方
// import { redirectToLogin } from './auth';
// 为了演示，暂时在这里简单定义一个
function redirectToLogin() {
	console.log('需要登录，正在跳转到登录页...');
	// 获取当前页面栈
	const pages = getCurrentPages();
	const currentPage = pages[pages.length - 1];
	// 判断当前是否已在登录页，避免重复跳转
	if (currentPage && currentPage.route && currentPage.route.includes('pages/common/login/login')) {
		console.log('已在登录页，不再重复跳转');
		return;
	}
	uni.navigateTo({
		url: '/pages/common/login/login' // 请替换为您的实际登录页面路径
	});
}

export async function callCloudApi(serviceName, methodName, params = {}, { showToast = true, customLoading = false } = {}) {
	if (!customLoading) {
		uni.showLoading({ title: '加载中...', mask: true });
	}
	console.log(`调用云服务: ${serviceName}.${methodName}`, JSON.stringify(params));
	const service = uniCloud.importObject(serviceName, {
		customUI: true // customUI:true 表示前端调用，云对象内部可用uniIdToken等上下文
	});

	try {
		const res = await service[methodName](params);
		console.log(`云服务 ${serviceName}.${methodName} 返回:`, JSON.stringify(res));

		if (!customLoading) {
			uni.hideLoading();
		}

		// 统一处理登录失效和Token无效 (errCode需要与云端抛出的一致)
		const loginErrCodes = ['LOGIN_REQUIRED', 'TOKEN_INVALID', 'uniIdTokenInvalid']; // 根据您云端实际抛出的错误码调整
		if (res && res.errCode && loginErrCodes.includes(res.errCode)) {
			console.error('API调用需要登录或Token无效:', res.errMsg);
			redirectToLogin();
			// 返回一个Promise.reject，让调用方知道请求未成功，可以中断后续操作
			return Promise.reject(res);
		}

		// 处理其他业务错误 (例如，云函数返回了 errCode 但不是登录相关)
		if (res && res.errCode) {
			console.error(`云服务 ${serviceName}.${methodName} 业务错误:`, res.errMsg);
			if (showToast && res.errMsg) {
				uni.showToast({ title: res.errMsg, icon: 'none', duration: 2000 });
			}
			return Promise.reject(res);
		}
		
		// 兼容处理早期可能存在的 { code !== 0, message: '...' } 的格式
		if (res && res.code !== undefined && res.code !== 0) {
		    console.error(`云服务 ${serviceName}.${methodName} 业务错误:`, res.message);
		    if (showToast && res.message) {
		        uni.showToast({ title: res.message, icon: 'none', duration: 2000 });
		    }
		    return Promise.reject(res);
		}


		// 业务成功 (通常云函数返回 {errCode: 0, data: ...} 或直接返回数据)
		// 如果您的云函数成功时返回 { errCode: 0, data: ... }, 那么直接返回 res 即可
		// 如果成功时直接返回数据，那么也是直接返回 res
		return res; // 对于 {errCode:0, data}, 调用方取 res.data

	} catch (e) { // uniCloud.callFunction 或 service[methodName] 可能直接抛出JS错误对象
		if (!customLoading) {
			uni.hideLoading();
		}
		console.error(`调用云服务 ${serviceName}.${methodName} 捕获到JS异常:`, e);
		const loginJsErrCodes = ['uniIdTokenInvalid']; // 某些uni-id的错误可能直接以JS错误形式抛出
		if (e && e.message && loginJsErrCodes.some(code => e.message.includes(code))) {
			redirectToLogin();
		} else if (showToast) {
			uni.showToast({
				title: e.errMsg || e.message || '请求失败，请稍后重试',
				icon: 'none',
				duration: 2000
			});
		}
		return Promise.reject(e); // 确保调用方能 catch 到错误
	}
}
```
您需要将此文件中的 `redirectToLogin` 函数的跳转路径 `/pages/common/login/login` 修改为您项目中实际的登录页面路径。
同时，错误码 `LOGIN_REQUIRED`, `TOKEN_INVALID`, `uniIdTokenInvalid` 等需要与您云端实际使用的错误码保持一致。

接下来，我们可以在 `main.js` 中将其挂载到 Vue 原型上，方便页面调用：
```javascript
// main.js
import Vue from 'vue'
import App from './App'
import { callCloudApi } from '@/utils/api.js' // 假设 api.js 在 utils 目录下

Vue.prototype.$api = callCloudApi

// ... 其他配置
```

现在，以 `pages/tabbar/site/index.vue` 中的 `getSiteList` 方法为例进行重构：

**原代码 (部分)：**
```vue
<script>
// ...
export default {
	// ...
	methods: {
		async getSiteList() {
			try {
				this.loading = true
				console.log('请求参数:', { keyword: this.keyword })

				const siteService = uniCloud.importObject('site-service')
				const res = await siteService.getSiteList({
					keyword: this.keyword,
				})

				console.log('工地列表返回:', res)

				if (res.code === 0) { // 假设旧的判断是 code === 0
					this.list = res.data.list
				} else {
					this.$showToast.none(res.message || '获取工地列表失败')
				}
			} catch (e) {
				console.error('获取工地列表异常:', e, e.code)
				// 旧的错误码判断是 401, 403
				if (e.code === 401 || e.code === 403) {
					redirectToLogin() // redirectToLogin 需要在页面中定义或引入
				} else {
                    // 其他错误处理
                    this.$showToast.none(e.message || '操作失败')
                }
			} finally {
				this.loading = false
				uni.stopPullDownRefresh()
				this.refreshTriggered = false
			}
		},
	}
}
</script>
```

**使用 `$api` 重构后：**
```vue
<script>
// ...
// 如果 redirectToLogin 不是全局的，且 $api 内部未处理跳转后的 reject，可能需要引入
// import { redirectToLogin } from '@/utils/auth.js'; // 假设

export default {
	// ...
	methods: {
		async getSiteList() {
			this.loading = true; // 手动控制 loading，因为 $api 默认会显示全局 loading
			console.log('请求参数:', { keyword: this.keyword });
			try {
				// 使用封装的 $api 调用
				// 传入 customLoading: true，让页面自行控制 loading 状态的显示与隐藏，避免 $api 的全局 loading 与页面 loading 冲突
				const res = await this.$api('site-service', 'getSiteList', {
					keyword: this.keyword,
				}, { customLoading: true }); // 传递 customLoading 选项

				// $api 成功时会 resolve(res)。
				// 假设云函数成功返回 { errCode: 0, data: {...} } 或者直接是数据
				// 如果返回的是 { errCode: 0, data: {...} }
				if (res && res.errCode === 0) {
					this.list = res.data.list;
					console.log('工地列表获取成功:', this.list);
				} else if (res && !res.errCode && typeof res === 'object') {
                    // 兼容云函数直接返回数据对象的情况（非规范的 {errCode:0, data} 结构）
                    // 此时需要根据业务具体判断 res 是否为有效数据
                    // 例如，如果列表数据直接是数组：
                    if (Array.isArray(res.list)) { // 假设返回 { list: [] }
                         this.list = res.list;
                         console.log('工地列表获取成功 (直接数据):', this.list);
                    } else {
                        //  如果 $api 内部已经对业务错误做了toast，这里可能不需要额外处理
                        //  但如果希望针对性处理或记录，可以添加逻辑
                        console.warn('获取工地列表成功，但数据格式非预期(非errCode:0):', res);
                        // this.$showToast.none('获取工地列表数据格式错误');
                    }
                }
                // 如果 $api 内部对业务错误（非登录错误）已经进行了toast提示并 reject，
                // 那么成功的 res 就一定是业务真正成功的数据，上述 else if 和后续的 catch 中的业务错误处理可以简化。
                // 当前 $api 实现是：业务错误会 reject，所以执行到这里，res 通常是成功的。

			} catch (e) {
				// $api 在遇到任何错误 (登录跳转后、业务错误、JS或网络错误) 时会 reject
				// $api 内部已经处理了登录跳转和通用错误提示 (showToast: true 时)
				console.error('getSiteList 调用 $api 发生错误:', e);
				// 一般情况下，如果 $api 的 showToast 为 true，这里不需要再额外 toast 提示相同错误
				// 但如果某些特定错误希望有不同于全局的提示，可以在这里根据 e 的内容判断并覆盖
				// 例如，如果 e 是 { errCode: 'SPECIFIC_BUSINESS_ERROR', errMsg: '...' }
				// if (e.errCode === 'SPECIFIC_BUSINESS_ERROR') {
				// this.$showToast.error(e.errMsg);
				// }
				// 如果 $api 中 showToast: false，则所有错误提示都需要在这里处理
				if (e && e.errMsg) { // 优先使用 errMsg
				    // this.$showToast.none(e.errMsg); // 如果$api没弹，这里可以弹
				} else if (e && e.message) { // 兼容普通 Error 对象
				    // this.$showToast.none(e.message);
				}
                // 清空列表，防止显示旧数据
                this.list = [];
			} finally {
				this.loading = false;
				uni.stopPullDownRefresh();
				this.refreshTriggered = false;
			}
		},
	}
}
</script>
```
**重构说明：**
1.  页面调用从 `uniCloud.importObject(...).method(...)` 变为 `this.$api('service-name', 'method-name', params, options)`。
2.  `try...catch` 结构依然保留在页面，但主要用于处理 `this.$api` `reject` 之后页面自身的逻辑（比如更新 `loading`状态，或者对某些特定错误进行特殊UI展示）。
3.  登录token失效的判断和跳转逻辑被统一移到了 `$api` 函数内部，页面代码不再需要重复编写。
4.  通用的错误提示（如网络错误、非登录相关的业务错误）也可以由 `$api` 内部统一处理（通过 `showToast` 选项控制）。页面可以只关注业务成功时的数据处理和特定错误的定制化处理。
5.  我更新了 `callCloudApi` 的实现，加入了 `showToast` 和 `customLoading` 选项，增加了对 `errCode` 为0但非登录业务错误的处理，使其更灵活。在 `getSiteList` 调用时，因为页面本身有 `this.loading` 控制，所以传递了 `{ customLoading: true }` 来避免 `$api` 内部的全局 `uni.showLoading`。

**2. 关于修改工作量**

是的，如果项目中已经存在大量直接调用云对象的地方，将它们全部修改为通过新的 `$api` 函数来调用，确实会涉及一定的初始工作量。每一处调用都需要：
*   替换调用方式。
*   调整参数传递。
*   检查并适配错误处理逻辑（因为一部分错误处理移到了 `$api` 中）。
*   测试。

**应对策略和收益：**

*   **长期收益远大于短期投入**：
    *   **代码更简洁、可读性更高**：页面逻辑更专注于业务本身。
    *   **维护性增强**：登录逻辑、通用错误处理、未来可能的全局请求头、加解密等，都可以在 `$api` 一处修改，全局生效。
    *   **减少Bug**：避免在每个页面重复实现登录校验和错误处理，减少出错的可能。
*   **渐进式重构**：
    *   您**不必一次性修改所有**。可以先在**新开发的功能模块**中强制使用新的 `$api`。
    *   对于**存量代码**，可以采用“边维护边重构”的策略：当您修改某个旧模块的功能或修复Bug时，顺便将其中的云对象调用方式重构为使用 `$api`。
    *   优先重构那些**调用频繁、逻辑复杂或之前错误处理不完善**的地方。
*   **工具辅助**：
    *   可以利用IDE的全局搜索功能，查找所有 `uniCloud.importObject` 或特定服务名（如 `'site-service'`）的调用点，列出清单，然后逐个修改。

虽然有工作量，但为了项目的健康和长远发展，这是一项非常值得的投资。统一的API调用层是前端工程化的重要实践之一。

您可以先尝试在一个或几个页面中进行这样的重构，体验一下效果，然后再制定详细的计划来逐步推广到整个项目。

接下来，我将根据您的确认，开始创建云端的公共校验模块 `common/auth-filter/index.js`。

```javascript
// utils/api.js

// 引入或定义 redirectToLogin
// 假设 redirectToLogin 函数定义在 utils/auth.js 或类似地方
// import { redirectToLogin } from './auth';
// 为了演示，暂时在这里简单定义一个
function redirectToLogin() {
	console.log('需要登录，正在跳转到登录页...');
	// 获取当前页面栈
	const pages = getCurrentPages();
	const currentPage = pages[pages.length - 1];
	// 判断当前是否已在登录页，避免重复跳转
	if (currentPage && currentPage.route && currentPage.route.includes('pages/common/login/login')) {
		console.log('已在登录页，不再重复跳转');
		return;
	}
	uni.navigateTo({
		url: '/pages/common/login/login' // 请替换为您的实际登录页面路径
	});
}

export async function callCloudApi(serviceName, methodName, params = {}, { showToast = true, customLoading = false } = {}) {
	if (!customLoading) {
		uni.showLoading({ title: '加载中...', mask: true });
	}
	console.log(`调用云服务: ${serviceName}.${methodName}`, JSON.stringify(params));
	const service = uniCloud.importObject(serviceName, {
		customUI: true // customUI:true 表示前端调用，云对象内部可用uniIdToken等上下文
	});

	try {
		const res = await service[methodName](params);
		console.log(`云服务 ${serviceName}.${methodName} 返回:`, JSON.stringify(res));

		if (!customLoading) {
			uni.hideLoading();
		}

		// 统一处理登录失效和Token无效 (errCode需要与云端抛出的一致)
		const loginErrCodes = ['LOGIN_REQUIRED', 'TOKEN_INVALID', 'uniIdTokenInvalid']; // 根据您云端实际抛出的错误码调整
		if (res && res.errCode && loginErrCodes.includes(res.errCode)) {
			console.error('API调用需要登录或Token无效:', res.errMsg);
			redirectToLogin();
			// 返回一个Promise.reject，让调用方知道请求未成功，可以中断后续操作
			return Promise.reject(res);
		}

		// 处理其他业务错误 (例如，云函数返回了 errCode 但不是登录相关)
		if (res && res.errCode) {
			console.error(`云服务 ${serviceName}.${methodName} 业务错误:`, res.errMsg);
			if (showToast && res.errMsg) {
				uni.showToast({ title: res.errMsg, icon: 'none', duration: 2000 });
			}
			return Promise.reject(res);
		}
		
		// 兼容处理早期可能存在的 { code !== 0, message: '...' } 的格式
		if (res && res.code !== undefined && res.code !== 0) {
		    console.error(`云服务 ${serviceName}.${methodName} 业务错误:`, res.message);
		    if (showToast && res.message) {
		        uni.showToast({ title: res.message, icon: 'none', duration: 2000 });
		    }
		    return Promise.reject(res);
		}


		// 业务成功 (通常云函数返回 {errCode: 0, data: ...} 或直接返回数据)
		// 如果您的云函数成功时返回 { errCode: 0, data: ... }, 那么直接返回 res 即可
		// 如果成功时直接返回数据，那么也是直接返回 res
		return res; // 对于 {errCode:0, data}, 调用方取 res.data

	} catch (e) { // uniCloud.callFunction 或 service[methodName] 可能直接抛出JS错误对象
		if (!customLoading) {
			uni.hideLoading();
		}
		console.error(`调用云服务 ${serviceName}.${methodName} 捕获到JS异常:`, e);
		const loginJsErrCodes = ['uniIdTokenInvalid']; // 某些uni-id的错误可能直接以JS错误形式抛出
		if (e && e.message && loginJsErrCodes.some(code => e.message.includes(code))) {
			redirectToLogin();
		} else if (showToast) {
			uni.showToast({
				title: e.errMsg || e.message || '请求失败，请稍后重试',
				icon: 'none',
				duration: 2000
			});
		}
		return Promise.reject(e); // 确保调用方能 catch 到错误
	}
}
```

```javascript
// main.js
import Vue from 'vue'
import App from './App'
import { callCloudApi } from '@/utils/api.js' // 假设 api.js 在 utils 目录下

Vue.prototype.$api = callCloudApi

// ... 其他配置
```

```vue
<script>
// ...
export default {
	// ...
	methods: {
		async getSiteList() {
			try {
				this.loading = true
				console.log('请求参数:', { keyword: this.keyword })

				const siteService = uniCloud.importObject('site-service')
				const res = await siteService.getSiteList({
					keyword: this.keyword,
				})

				console.log('工地列表返回:', res)

				if (res.code === 0) { // 假设旧的判断是 code === 0
					this.list = res.data.list
				} else {
					this.$showToast.none(res.message || '获取工地列表失败')
				}
			} catch (e) {
				console.error('获取工地列表异常:', e, e.code)
				// 旧的错误码判断是 401, 403
				if (e.code === 401 || e.code === 403) {
					redirectToLogin() // redirectToLogin 需要在页面中定义或引入
				} else {
                    // 其他错误处理
                    this.$showToast.none(e.message || '操作失败')
                }
			} finally {
				this.loading = false
				uni.stopPullDownRefresh()
				this.refreshTriggered = false
			}
		},
	}
}
</script>
```

```vue
<script>
// ...
// 如果 redirectToLogin 不是全局的，且 $api 内部未处理跳转后的 reject，可能需要引入
// import { redirectToLogin } from '@/utils/auth.js'; // 假设

export default {
	// ...
	methods: {
		async getSiteList() {
			this.loading = true; // 手动控制 loading，因为 $api 默认会显示全局 loading
			console.log('请求参数:', { keyword: this.keyword });
			try {
				// 使用封装的 $api 调用
				// 传入 customLoading: true，让页面自行控制 loading 状态的显示与隐藏，避免 $api 的全局 loading 与页面 loading 冲突
				const res = await this.$api('site-service', 'getSiteList', {
					keyword: this.keyword,
				}, { customLoading: true }); // 传递 customLoading 选项

				// $api 成功时会 resolve(res)。
				// 假设云函数成功返回 { errCode: 0, data: {...} } 或者直接是数据
				// 如果返回的是 { errCode: 0, data: {...} }
				if (res && res.errCode === 0) {
					this.list = res.data.list;
					console.log('工地列表获取成功:', this.list);
				} else if (res && !res.errCode && typeof res === 'object') {
                    // 兼容云函数直接返回数据对象的情况（非规范的 {errCode:0, data} 结构）
                    // 此时需要根据业务具体判断 res 是否为有效数据
                    // 例如，如果列表数据直接是数组：
                    if (Array.isArray(res.list)) { // 假设返回 { list: [] }
                         this.list = res.list;
                         console.log('工地列表获取成功 (直接数据):', this.list);
                    } else {
                        //  如果 $api 内部已经对业务错误做了toast，这里可能不需要额外处理
                        //  但如果希望针对性处理或记录，可以添加逻辑
                        console.warn('获取工地列表成功，但数据格式非预期(非errCode:0):', res);
                        // this.$showToast.none('获取工地列表数据格式错误');
                    }
                }
                // 如果 $api 内部对业务错误（非登录错误）已经进行了toast提示并 reject，
                // 那么成功的 res 就一定是业务真正成功的数据，上述 else if 和后续的 catch 中的业务错误处理可以简化。
                // 当前 $api 实现是：业务错误会 reject，所以执行到这里，res 通常是成功的。

			} catch (e) {
				// $api 在遇到任何错误 (登录跳转后、业务错误、JS或网络错误) 时会 reject
				// $api 内部已经处理了登录跳转和通用错误提示 (showToast: true 时)
				console.error('getSiteList 调用 $api 发生错误:', e);
				// 一般情况下，如果 $api 的 showToast 为 true，这里不需要再额外 toast 提示相同错误
				// 但如果某些特定错误希望有不同于全局的提示，可以在这里根据 e 的内容判断并覆盖
				// 例如，如果 e 是 { errCode: 'SPECIFIC_BUSINESS_ERROR', errMsg: '...' }
				// if (e.errCode === 'SPECIFIC_BUSINESS_ERROR') {
				// this.$showToast.error(e.errMsg);
				// }
				// 如果 $api 中 showToast: false，则所有错误提示都需要在这里处理
				if (e && e.errMsg) { // 优先使用 errMsg
				    // this.$showToast.none(e.errMsg); // 如果$api没弹，这里可以弹
				} else if (e && e.message) { // 兼容普通 Error 对象
				    // this.$showToast.none(e.message);
				}
                // 清空列表，防止显示旧数据
                this.list = [];
			} finally {
				this.loading = false;
				uni.stopPullDownRefresh();
				this.refreshTriggered = false;
			}
		},
	}
}
</script>
```

